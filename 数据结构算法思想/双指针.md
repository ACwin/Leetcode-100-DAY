双指针技巧可以分为两类，一类是快慢指针，一类是左右指针。前者解决主要解决链表中的问题，比如典型的判定链表中是否包含环；后者主要解决数组（或者字符串）中的问题，比如二分查找。

### 一、快慢指针的常见算法

快慢指针一般都初始化指向链表的头结点 head，前进时快指针 fast 在前，慢指针 slow 在后，巧妙解决一些链表中的问题。

**1、判定链表中是否含有环**

单链表的特点是每个节点只知道下一个节点，所以一个指针的话无法判断链表中是否含有环的。

如果链表中不含环，那么这个指针最终会遇到空指针 null。

```C++
public boolean hasCycle(ListNode head) {
    while (head != null){
        head = head ->next;
    }
    return false;
}
```
但如果链表中含有环，那么这个指针就会陷入死循环，因为环形数组中没有 null 指针作为尾部节点。

> 经典解法就是用两个指针，一个每次前进两步，一个每次前进一步。如果不含有环，跑得快的那个指针最终会遇到 null，说明链表不含环；如果含有环，快指针最终会超慢指针一圈，和慢指针相遇，说明链表含有环。

```C++
public boolean hasCycle(ListNode head){
    ListNode* fast, slow;
    fast = slow = head;
    while(fast != null && fast.next != null){
        fast = fast->next->next;
        slow = slow->next;
        if(fast == slow){
            return true;
        }
    }
    return false;
}
```
**2、已知链表中含有环，返回这个环的起始位置**
> 具体看Leetcode 142.环形链表II

```C++
class Solution {
public:
    ListNode *detectCycle(ListNode *head) {
        ListNode* fast = head;
        ListNode* slow = head;
        while(fast != NULL && fast->next != NULL) {
            slow = slow->next;
            fast = fast->next->next;
            if (slow == fast) {
                ListNode* index1 = fast;
                ListNode* index2 = head;
                while (index1 != index2) {
                    index1 = index1->next;
                    index2 = index2->next;
                }
                return index2; 
            }
        }
        return NULL;
    }
};
```
**3、寻找链表的中点**

> 类似上面的思路，我们还可以让快指针一次前进两步，慢指针一次前进一步，当快指针到达链表尽头时，慢指针就处于链表的中间位置。
```C++
public static ListNode findMid(ListNode head) {
    ListNode slow, fast;
    slow = fast = head;
    while (fast != null && fast.next != null) {
        fast = fast->next->next;
        slow = slow->next;
    }
    return slow;// slow 就在中间位置
}    

```
当链表的长度是奇数时，slow 恰巧停在**中点位置**；如果长度是偶数，slow 最终的位置是**中间偏右**。

寻找链表中点的一个重要作用是对链表进行**归并排序**，可以用二分法解决。

**4、删除链表的倒数第n个元素**
>如果要删除倒数第n个节点，让快指针先走 n 步，然后让fast和slow同时移动，直到fast指向链表末尾。最后删掉slow所指向的节点。

```C++
class Solution {
public:
    ListNode* removeNthFromEnd(ListNode* head, int n) {
        ListNode* dummyHead = new ListNode(0);
        dummyHead->next = head;
        ListNode* slow = dummyHead;
        ListNode* fast = dummyHead;
        while(n-- && fast != NULL) {
            fast = fast->next;
        }
        fast = fast->next; // fast再提前走一步，因为需要让slow指向删除节点的上一个节点
        while (fast != NULL) {
            fast = fast->next;
            slow = slow->next;
        }
        slow->next = slow->next->next;
        return dummyHead->next;
    }
};


```
二、左右指针的常用算法

左右指针在数组中实际是指两个索引值，一般初始化为 left = 0, right = nums.length - 1 。


